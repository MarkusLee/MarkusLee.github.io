<!DOCTYPE html>
<html lang="en">
    <!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
  
  <title>OnJava8Notes - MarcusLee&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
<link rel="stylesheet" href="/css/waline.css">

  
  
  
<link rel="stylesheet" href="/css/post.css">

  

  
<meta name="generator" content="Hexo 5.4.0"></head>
    <body>
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Marcus Lee</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/MarkusLee" target="_blank">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        <article class="post">
    <div class="meta">
        
        <div class="date" id="date">
            
            
            
            
            
            <span>May</span>
            
            
            
            
            
            
            
            
            <span>10,</span>
            <span>2021</span>
        </div>
        

        <h2 class="title">OnJava8Notes</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <h1 id="On-Java-8-Notes"><a href="#On-Java-8-Notes" class="headerlink" title="On Java 8 Notes"></a>On Java 8 Notes</h1><h2 id="1-对象的概念"><a href="#1-对象的概念" class="headerlink" title="1  对象的概念"></a>1  对象的概念</h2><ul>
<li>创建基类以表示思想的核心，从基类中派生出其他类型来表示实现该核心的不同方式</li>
<li>判断是否继承，就看在类之间是否有 <strong>IS-A</strong> 关系</li>
<li>早期绑定 -&gt; 后期绑定</li>
<li>单继承结构：最终基类为Object</li>
</ul>
<h2 id="3-万物皆对象"><a href="#3-万物皆对象" class="headerlink" title="3 万物皆对象"></a>3 万物皆对象</h2><ul>
<li><p>栈内存</p>
<ul>
<li>通过栈指针的上下移动分配/释放内存</li>
<li>对象引用存在于栈内存</li>
</ul>
</li>
<li><p>堆内存</p>
<ul>
<li>（一大块内存</li>
<li>编译器不需要知道对象必须在堆内存上停留多长时间</li>
<li>分配和清理堆内存速度慢于栈内存（无需过分担心）</li>
</ul>
</li>
<li><p>基本类型</p>
<ul>
<li>直接存储在栈内存（更高效）</li>
<li>会默认初始化（每位赋值为0）</li>
<li>为了安全最好始终显式地初始化变量</li>
<li>没有sizeof() ！</li>
</ul>
</li>
<li><p>高精度数值：BigInteger BigDecimal</p>
</li>
<li><p>static</p>
<ul>
<li>情况<ul>
<li>只想为特定字段分配一个共享存储空间，而不去考虑究竟要创建多少对象（或者不创建对象）</li>
<li>创建一个与此类的任何对象无关的方法（即使没有创建对象，也能调用该方法）</li>
</ul>
</li>
<li>不依赖于任何特定的对象实例</li>
<li>对于同一类的多个对象，该类中的一个静态变量只占一份存储空间（共享相同的变量）</li>
</ul>
</li>
</ul>
<h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4 运算符"></a>4 运算符</h2><ul>
<li><p>对对象进行操作的时候，实际上操作的是它的引用</p>
</li>
<li><p>随机数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);  <span class="comment">//设置seed</span></span><br><span class="line"><span class="keyword">int</span> j = rand.nextInt(<span class="number">100</span>) + <span class="number">1</span>; <span class="comment">//100为设置的上限</span></span><br><span class="line"><span class="keyword">float</span> f = rand.nextFloat();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一元减号可以得到数据的负值，一元加号可以得到数据的正值（较小的数值类型会自动提升到int）</p>
</li>
<li><p>对象的等价</p>
<ul>
<li>== 和 != 比较的是对象的<strong>引用</strong></li>
<li>Integer内部维护着一个IntergerCache的缓存</li>
<li>推荐使用equals()<ul>
<li>equals()的默认行为是比较对象的引用，需要Override</li>
</ul>
</li>
</ul>
</li>
<li><p>字面值常量<br>  在添加字符可以让编译器识别该文本值的类型</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hexint = <span class="number">0x2f</span>;  <span class="comment">//hex</span></span><br><span class="line"><span class="keyword">int</span> octint = <span class="number">0177</span>;  <span class="comment">//octal</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0xffff</span>; <span class="comment">//max</span></span><br><span class="line"><span class="keyword">long</span> n1 = <span class="number">200L</span>;</span><br><span class="line"><span class="keyword">long</span> n2 = <span class="number">200l</span>; <span class="comment">//not recommended</span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">1F</span>;</span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">1f</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">1D</span>;</span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">1d</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>下划线</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">341_435.445_667</span>;</span><br><span class="line"><span class="keyword">int</span> bin = <span class="number">0b0010_1111_1110</span>;</span><br><span class="line"><span class="keyword">long</span> hex = <span class="number">0x7f_e9_b7_aa</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>仅限单下划线</li>
<li>开头和结尾不允许出现下划线</li>
<li>后缀 F, D, L 前后不允许出现下划线</li>
<li>前导 b, x 前后不允许出现下划线</li>
</ol>
</li>
<li><p>%n<br>  java中平台自适应的换行符，适用于</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf();</span><br><span class="line">System.out.format();</span><br><span class="line"><span class="comment">//System.out.println();必须使用\n</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符串</p>
<ul>
<li>“” + 基本类型数据 可以隐式地将其转换为字符串</li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li>向下转换需要显式使用</li>
<li>向上转换可以隐式（因为不会造成信息丢失）</li>
</ul>
</li>
<li><p>舍入</p>
<ul>
<li>Math.round()方法</li>
</ul>
</li>
</ul>
<h2 id="5-控制流"><a href="#5-控制流" class="headerlink" title="5 控制流"></a>5 控制流</h2><ul>
<li><p>for-in</p>
<ul>
<li>适用于任何可迭代的对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> x : f)&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">10</span>))&#123;</span><br><span class="line">    System.out.println(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>带标签的break以及continue方法</p>
<ul>
<li>适用于循环嵌套</li>
</ul>
</li>
</ul>
<h2 id="6-初始化和清理"><a href="#6-初始化和清理" class="headerlink" title="6 初始化和清理"></a>6 初始化和清理</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li><p>对象的创建和初始化是统一的概念，二者不可分割</p>
</li>
<li><p>构造器<strong>没有返回值</strong></p>
</li>
<li><p>如果创建一个类，类中没有构造器，那么编译器就会自动创建一个无参构造器</p>
</li>
<li><p>this关键字只能在<strong>非静态</strong>方法内部使用</p>
</li>
<li><p>调用一个对象的方法时，this生成了一个对象引用</p>
</li>
<li><p>在构造器中调用构造器</p>
<ul>
<li>通过this()调用一次构造器</li>
<li>必须首先调用构造器</li>
<li>不允许在一个构造器之外的方法里调用构造器</li>
</ul>
</li>
<li><p>finalize()方法？很奇怪</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p>指定初始化</p>
<ul>
<li>在定义时赋初值</li>
<li>或者调用某个方法（不能带有未初始化的类成员变量作为参数）</li>
</ul>
</li>
<li><p>构造器初始化</p>
<ul>
<li>编译器不会强制要求在构造器中初始化（会默认初始化）</li>
</ul>
</li>
<li><p>静态初始化</p>
<ul>
<li><p>只有在必要时刻进行</p>
</li>
<li><p><strong>一开始存储空间赋为0，先静态后非静态，先父类后子类，先成员后构造器，其余按代码顺序</strong> (?)</p>
</li>
<li><p>显式静态初始化</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">foo</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一个类当它任意一个static成员被访问时，就会被加载</p>
</li>
<li><p>static变量只初始化一次</p>
</li>
</ul>
</li>
<li><p>非静态实例初始化</p>
</li>
<li><p>数组</p>
<ul>
<li><p>初始化</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a2 = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a3 = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)]; <span class="comment">//动态数组创建</span></span><br></pre></td></tr></table></figure></li>
<li><p>数组有固定成员length</p>
</li>
<li><p>非基本类型的数组为引用数组</p>
</li>
<li><p>Arrays.toString() 产生一维数组的可打印版本</p>
</li>
</ul>
</li>
<li><p>可变参数列表</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray1</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray2</span><span class="params">(Objetc... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object obj : args)&#123;</span><br><span class="line">        System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指定参数时，编译器会填充数组，获取的仍然是一个数组</li>
<li>可变参数的个数可以为 0</li>
</ul>
</li>
<li><p>枚举类型</p>
<ul>
<li><p>实例是常量，都用<strong>大写字母</strong>表示，多个单词使用下划线分割</p>
</li>
<li><p>常用在<em>switch</em>语句中</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Spiciness</span></span>&#123;NOT, MILD, MEDIUM, HOT, FLAMING&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>toString() 显示名称</p>
</li>
<li><p>ordinal() 序号</p>
</li>
</ul>
</li>
</ul>
<h2 id="7-封装"><a href="#7-封装" class="headerlink" title="7 封装"></a>7 封装</h2><ul>
<li><p>封装 (encapsulation)</p>
<ul>
<li>将数据和方法装进类中，将具体实现隐藏</li>
</ul>
</li>
<li><p>包 (package)</p>
<ul>
<li>管理命名空间</li>
<li>一个java源代码文件称为一个编译单元 (compile unit)<ul>
<li>每个编译单元中最多有一个public类，且类名必须与文件名相同</li>
</ul>
</li>
<li>package语句必须是文件中（除了注释之外）<strong>第一行</strong>代码</li>
<li>包名一律小写</li>
<li>创建一个包时，包名隐含了目录结构，这个包必须位于包名指定的目录中，该目录必须在以CLASSPATH开始的目录中可以查询到</li>
<li>使用import / 使用完整的[包名.类名]来调用</li>
</ul>
</li>
<li><p>访问权限修饰符</p>
<ul>
<li><em>public</em>: 对于每个人都是可用的</li>
<li><em>(default)</em>: 默认包访问权限，为该目录中所有的其他文件提供包访问权限<ul>
<li>不加任何修饰符即得到该权限</li>
</ul>
</li>
<li><em>private</em>: 除了包含该成员的类，其它任何类都无法访问这个成员<ul>
<li>将方法标记为private：确保不会被误用，防止改变和删除<br>  例如：将构造器标记为private，防止直接访问构造器，而是需要通过调用额外的方法</li>
</ul>
</li>
<li><em>protected</em>: 继承访问权限<ul>
<li>基类的某个成员能被继承类访问，但是不能被其他类访问</li>
<li>可以看成是“介于default和public之间”</li>
</ul>
</li>
<li>类既不能是private也不能是protected</li>
</ul>
</li>
</ul>
<h2 id="8-复用"><a href="#8-复用" class="headerlink" title="8 复用"></a>8 复用</h2><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>composition<br>在新类中创建现有类的对象</p>
<p>在新类中包含一个已有类的功能</p>
<p>初始化引用的四种方法 （类的成员是对其他类的引用）</p>
<ol>
<li>当对象被定义时候（先于构造函数）</li>
<li>在该类的构造函数中</li>
<li>在实际使用对象之前（<strong>延迟初始化</strong>）</li>
<li>使用实例初始化</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>inheritance</p>
<p>使用一个通用类，并为了某个特殊需求将其特殊化</p>
<p>优先使用组合，<strong>必要时才使用继承</strong>（新类是否需要向上转型？需要的话才考虑继承）</p>
<ul>
<li><p>初始化基类</p>
<ul>
<li>无参：可以忽略（编译器自动）</li>
<li>有参：在构造函数中调用父类的构造函数super()</li>
</ul>
</li>
<li><p>委托 (delegation)</p>
<ul>
<li>将方法转发到底层对象</li>
<li>可以在成员对象中提供方法的子集</li>
</ul>
</li>
<li><p>清理</p>
<ul>
<li>一般只需要垃圾收集器</li>
<li>使用自己的清理方法，不要使用finalize() (?)</li>
</ul>
</li>
<li><p>向上转型永远是安全的</p>
</li>
<li><p><em>final</em> 关键字</p>
<p>  谨慎使用final修饰方法</p>
<p>  不必用final提升性能</p>
<ul>
<li>final 数据<ul>
<li>一个永不改变的编译时常量 / 一个在运行时初始化后就不会改变的值</li>
<li>数据在编译时不一定可知</li>
<li>static final 同时修饰后，占用一段不能改变的存储空间（命名全大写）</li>
<li>final修饰对象引用时，对象仍然可以改变</li>
<li>final数据必须初始化</li>
</ul>
</li>
<li>final 参数<ul>
<li>只读，无法修改</li>
</ul>
</li>
<li>final 方法<ul>
<li>给方法上锁，防止被覆写</li>
<li>private方法都被隐式地指定为final</li>
<li>覆写基类的private方法实际上是新建了一个无关的同名方法（使用@Override进行检查）</li>
</ul>
</li>
<li>final 类<ul>
<li>不能被继承</li>
</ul>
</li>
</ul>
</li>
<li><p>在设计一个系统时，目标是发现或创建一系列类，每个类有特定的用途，而且既不应太大(包括太多功能难以复用)，也不应太小(不添加其他功能就无法使用)。如果设计变得过于复杂，通过将现有类拆分为更小的部分而添加更多的对象,通常是有帮助的。</p>
</li>
<li><p>当开始设计一个系统时，记住程序开发是一个增量过程，正如人类学习。它依赖实验，你可以尽可能多做分析，然而在项目开始时仍然无法知道所有的答案。如果把项目视作一个有机的，进化着的生命去培养，而不是视为像摩天大楼一样快速见效，就能获得更多的成功和更迅速的反馈。继承和组合正是可以让你执行如此实验的面向对象编程中最基本的两个工具。</p>
</li>
</ul>
<h2 id="9-多态"><a href="#9-多态" class="headerlink" title="9 多态"></a>9 多态</h2><ul>
<li>绑定：将一个方法调用和一个方法主体相关联</li>
<li>后期绑定<br>  （动态绑定，运行时绑定）<ul>
<li>在运行时能过够判断对象的类型，从而调用正确的方法</li>
<li>在编译时，编译器<strong>不</strong>需要知道任何具体信息以进行正确的调用</li>
<li>除static, final, (private)外，所有方法都是后期绑定</li>
</ul>
</li>
<li>属性和静态方法没有多态这一特点<ul>
<li>但是一般都将属性设置为private，自然地避开了这个问题</li>
</ul>
</li>
<li>清理<ul>
<li>重写清理函数时，需要调用基类的清理函数</li>
<li>顺序与构造器相反，先清理派生类后清理基类</li>
<li>对于共享的对象，需要跟踪引用数 </li>
</ul>
</li>
<li>编写构造器的规范：<strong>做尽量少的事让对象进入良好状态，尽量不要调用类中的任何方法</strong></li>
<li>如果在派生类中覆写了基类构造器中调用的方法，则初始化派生类对象时，初始化基类的所调用的该方法会是被覆写后的方法，而非基类中的方法</li>
<li>协变返回类型<ul>
<li>[派生类覆写的方法] 可以返回 [基类方法返回类型] 的派生类（因此不强制返回类型相同）</li>
</ul>
</li>
</ul>
<h2 id="10-接口"><a href="#10-接口" class="headerlink" title="10 接口"></a>10 接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>abstract</p>
<ul>
<li>包含抽象方法的类必须是抽象的</li>
<li>继承抽象类必须为所有抽象方法提供方法定义，否则新类仍然是抽象类</li>
<li>可以将不包含抽象方法的类修饰为abstract，从而防止创建类的对象</li>
<li>没有private abstract</li>
<li>作用<ul>
<li>能够告知用户和编译器使用意图</li>
<li>方便沿着继承层级结构上移公共方法</li>
</ul>
</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>interface</p>
<ul>
<li><p>使用接口的原因</p>
<ul>
<li>能够向上转型为多个基类型</li>
<li>防止创建这个类的对象</li>
</ul>
</li>
<li><p>只能描述类应该像什么、做什么，但是不能描述怎么做</p>
</li>
<li><p>只能确定方法名、参数列表和返回类型，但是无法确定方法体</p>
</li>
<li><p>接口常常代表一个<strong>形容词</strong> (Runnable, Serializable) ，而抽象类通常是一件事物的类型 (String, ActionHero)</p>
</li>
<li><p>接口可以包含属性（隐式指明为static final）</p>
<ul>
<li>可以用来创建常量（但是enum更好）</li>
</ul>
</li>
<li><p>接口中的方法默认为public</p>
</li>
<li><p>Java8中允许接口包含默认方法和静态方法</p>
<ul>
<li>默认方法 default<ul>
<li>任何实现接口却没有定义方法的时候可以使用default创建的方法体</li>
<li>通过默认方法具有某种多继承的特性（虽然Java严格单继承）</li>
<li>不能同时实现包含 [相同方法签名的方法] 的接口，但是可以用Override规避这一问题</li>
</ul>
</li>
<li>静态方法<ul>
<li>能恰当地把工具功能置于接口中</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>组合</td>
<td>新类可以组合多个接口</td>
<td>只能继承单一抽象类</td>
</tr>
<tr>
<td>状态</td>
<td>不能包含属性（除了静态属性，不支持对象状态）</td>
<td>可以包含属性；非抽象方法可能引用这些属性</td>
</tr>
<tr>
<td>默认方法 &amp; 抽象方法</td>
<td>不需要在子类中实现默认方法；默认方法可以引用其它接口的方法</td>
<td>必须在子类中实现抽象方法</td>
</tr>
<tr>
<td>构造器</td>
<td>没有</td>
<td>可以有</td>
</tr>
<tr>
<td>可见性</td>
<td>隐式public</td>
<td>可以是protected或者”friendly”</td>
</tr>
</tbody></table>
<ul>
<li><p>更倾向于使用接口而不是抽象类 (?)</p>
<ul>
<li>如果创建不带任何方法定义或成员变量的基类，就选择接口</li>
<li>任何抽象性都应该是由真正的需求驱动的，当有必要时才应该使用接口进行重构，而不是到处添加额外的间接层，从而带来额外的复杂性</li>
</ul>
</li>
<li><p>将接口与实现<strong>解耦</strong>使得同一接口可以应用于多种不同的实现</p>
</li>
<li><p>接口的嵌套</p>
<ul>
<li>嵌套在<em>类</em>中的private接口<ul>
<li>强制该接口中的方法定义不可以向上转型</li>
<li>不能在定义它的类之外的地方被实现</li>
</ul>
</li>
<li>嵌套在<em>另一个接口</em>中的接口自动是public，不能是private</li>
</ul>
</li>
</ul>
<h2 id="11-内部类"><a href="#11-内部类" class="headerlink" title="11 内部类"></a>11 内部类</h2><ul>
<li><p>如果想从外部类的静态和非静态方法之外的任意位置创建某个内部类的对象，必须具体指明对象的类型 <em>OuterClassName.InnerClassName</em></p>
</li>
<li><p>内部类拥有其外部类的所有元素的访问权（包括private成员）</p>
</li>
<li><p><em>OuterClassName.this</em> 生成对外部类对象的引用</p>
</li>
<li><p><em>OuterClasssRef.new</em> 在某个外部类对象中创建内部类对象</p>
</li>
<li><p>无法在拥有外部类对象之前创建非静态内部类</p>
</li>
<li><p>创建内部类的理由</p>
<ul>
<li>实现某类型的接口，创建并返回对其的引用</li>
<li>创建一个辅助作用的类，但是又不希望这个类是public</li>
</ul>
</li>
<li><p>内部类的特点</p>
<ul>
<li>每个内部类能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响</li>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立</li>
<li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类</li>
<li>创建内部类对象的时刻并不依赖于外部类对象的创建</li>
<li>内部类并没有令人迷惑的”is-a”关系，它就是一个独立的实体。</li>
</ul>
</li>
</ul>
<ol>
<li>局部内部类：定义在方法中的类，类的可用性限制在方法内部</li>
<li>匿名内部类：在使用时定义的内部类 (?)</li>
<li>嵌套类：static内部类</li>
<li>接口的内部类</li>
</ol>
<ul>
<li>闭包 (closure)<ul>
<li>一个可调用的对象，记录了一些来自 [创建它的作用域] 的信息</li>
<li>内部类是面向对象的闭包</li>
</ul>
</li>
<li>剩下的放弃了。。。以后再看吧</li>
</ul>
<h2 id="12-集合"><a href="#12-集合" class="headerlink" title="12 集合"></a>12 集合</h2><p>collection</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul>
<li>类型推断 (type inference)：右侧可以忽略类型信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>向上转型可以作用于泛型，即可以将子类添加到基类集合中</p>
</li>
<li><p>添加元素组</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList();Collections.addAll();</span><br></pre></td></tr></table></figure></li>
<li><p>集合的打印</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.toString();</span><br></pre></td></tr></table></figure>

<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li>contains()：确定对象是否在列表中</li>
<li>remove()：删除一个对象</li>
<li>indexOf()：找到对象对应的下标</li>
<li>subList()：生成切片（对切片的修改会影响原列表）</li>
<li>containsAll()：contains的升级版</li>
<li>retainAll()：交集</li>
<li>removeAll()：删除指定元素</li>
<li>set()：替换元素</li>
<li>add()：添加一个</li>
<li>addAll()：添加多个</li>
<li>isEmpty()：判断是否为空</li>
<li>clear()：清空</li>
<li>toArray()：将Collection转换为数组</li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>  Iterator</p>
<ul>
<li><p>只能向前移动</p>
</li>
<li><p>单纯遍历List不需要迭代器，用for-in语法</p>
</li>
<li><p>生成list的迭代器可以在每个对象上执行操作</p>
</li>
<li><p><strong>统一了对集合的访问方式</strong>（到最后都是对迭代器进行操作）</p>
</li>
</ul>
<p>  Listiterator</p>
<ul>
<li>可以双向移动</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>  LinkedList</p>
<ul>
<li>实现基本的List接口</li>
<li>能被用作栈、队列和双端队列（通过使用额外的方法）</li>
<li>可以将Deque包装成Stack使用</li>
</ul>
<h4 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h4><p>  Set</p>
<ul>
<li>不保存重复的元素</li>
<li>具有与Collection相同的接口</li>
</ul>
<p>  HashSet / LinkedHashSet</p>
<p>  TreeSet</p>
<ul>
<li>使用红黑树</li>
<li>维持集合有序</li>
</ul>
<p>  Map</p>
<p>  Queue</p>
<p>  PriorityQueue</p>
</li>
</ul>
<h2 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC (Remote Procedure Call)"></a>RPC (Remote Procedure Call)</h2><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><p>从单机走向分布式，产生了很多分布式的通信方式：</p>
<ul>
<li>TCP/UDP的二进制传输<ul>
<li>最古老也是最有效，并且永不过时</li>
<li>事实上所有的通信方式归根结底都是TCP/UDP</li>
</ul>
</li>
<li>CORBA (Common Object Request Broker Architecture)<ul>
<li>古老而复杂的，支持面向对象的通信协议</li>
</ul>
</li>
<li>Web Service <ul>
<li>SOA SOAP RDDI WSDL …</li>
<li>基于http + xml的标准化Web API </li>
</ul>
</li>
<li>RestFul (Representational State Transfer)<ul>
<li>回归简单化本源的Web API的事实标准</li>
<li>http + json</li>
</ul>
</li>
<li>RMI (Remote Method Invocation)<ul>
<li>Java内部的分布式通信协议</li>
</ul>
</li>
<li>JMS Java Message Service<ul>
<li>JavaEE中的消息框架标准，为很多MQ所支持</li>
</ul>
</li>
<li>RPC ( Remote Method Call)<ul>
<li>远程方法调用，这只一个<strong>统称</strong>，重点在于方法调用(不支持对象的概念)</li>
<li>具体实现甚至可以用RMI, RestFul等去实现，但一般不用，因为RMI不能跨语言，而RestFul效率太低。</li>
<li>多用于服务器集群间的通信，因此常使用更加高效短小精悍的传输模式以提高效率。</li>
</ul>
</li>
</ul>
<h3 id="RPC-Serialization-Framework"><a href="#RPC-Serialization-Framework" class="headerlink" title="RPC Serialization Framework"></a>RPC Serialization Framework</h3><ol>
<li>java.io.Serializable</li>
<li>Hessian</li>
<li>Google protobuf</li>
<li>facebook Thrift</li>
<li>kyro</li>
<li>fst</li>
<li>json serialization framework<ol>
<li>Jackson</li>
<li>Google Gson</li>
<li>Ali FastJson</li>
</ol>
</li>
<li>xlmrpc (xstream)</li>
<li>…</li>
</ol>

    </div>

    <div class="about">
        <h1>About this Post</h1>
        <p>This post is written by Marcus Lee, licensed under <a
                target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
    </div>

    
        
    
</article>
        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h4 class="title">Blog</h4>
                
                <a href="/" class="item" target="_blank">Blog</a>
                
                <a href="/archives" class="item" target="_blank">Archives</a>
                
                <a href="/friends" class="item" target="_blank">Friends</a>
                
                <a href="/projects" class="item" target="_blank">Projects</a>
                
                <a href="/resume" class="item" target="_blank">Resume</a>
                
                <a href="/about" class="item" target="_blank">About</a>
                
                <a href="/atom.xml" class="item" target="_blank">RSS</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Projects</h4>
                
                <a href="https://github.com/transmister" class="item" target="_blank">Transmister</a>
                
                <a href="https://github.com/MrWillCom/css-and-js-windows-uwp-xaml-controls" class="item" target="_blank">CSS&amp;JS Windows UWP XAML Controls</a>
                
                <a href="https://github.com/MrWillCom/hexo-theme-cupertino" class="item" target="_blank">Theme Cupertino</a>
                
                <a href="https://github.com/MrWillCom/github-dark-mode" class="item" target="_blank">GitHub Dark Mode</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Me</h4>
                
                <a href="https://github.com/MarkusLee" class="item" target="_blank">GitHub</a>
                
                <a href="mailto:lxmarcus@foxmail.com" class="item" target="_blank">Email</a>
                
            </div>
            
        </div>
        &copy; 2021 Marcus Lee<br />
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
</footer>

        
<script src="/js/main.js"></script>

        
    </body>
</html>