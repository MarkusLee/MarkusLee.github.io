<!DOCTYPE html>
<html lang="en">
    <!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
  
  <title>HelloLife - MarcusLee&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
<link rel="stylesheet" href="/css/waline.css">

  
  
  
<link rel="stylesheet" href="/css/post.css">

  

  
<meta name="generator" content="Hexo 5.4.0"></head>
    <body>
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Marcus Lee</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/MarkusLee" target="_blank">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        <article class="post">
    <div class="meta">
        
        <div class="date" id="date">
            
            
            
            
            
            
            <span>June</span>
            
            
            
            
            
            
            
            <span>23,</span>
            <span>2021</span>
        </div>
        

        <h2 class="title">HelloLife</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <h1 id="计算机系统-大作业"><a href="#计算机系统-大作业" class="headerlink" title="计算机系统 大作业"></a>计算机系统 大作业</h1><p>题   目  程序人生-Hello’s P2P  </p>
<p>专    业     计算机类    </p>
<p>学    号    1190201520    </p>
<p>班    级     1903009     </p>
<p>学    生      李想     </p>
<p>指 导 教 师      吴锐      </p>
<p><strong>计算机科学与技术学院</strong></p>
<p>2021年5月</p>
<h2 id="摘-要"><a href="#摘-要" class="headerlink" title="摘 要"></a>摘 要</h2><p>本文借助Linux开发工具，对hello.c进行预处理、编译、汇编、链接等操作，分析了hello.c从源码到可执行目标文件的流程，详细阐释了每个过程在Linux下的实现机制。然后通过分析hello可执行目标文件从内存加载到结束退出的过程，反映出Linux系统的进程管理机制、存储层次结构、异常控制流、虚拟内存和IO管理等内容。通过对hello全生命周期的分析总结，对计算机系统课程的内容进行了一次较为全面的实践与总结。</p>
<p><strong>关键词：</strong>程序生命周期；Linux操作系统；汇编语言；C语言；              </p>
<p>[TOC]</p>
<h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h1><h2 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h2><h3 id="1-1-1-P2P-from-Program-to-Process"><a href="#1-1-1-P2P-from-Program-to-Process" class="headerlink" title="1.1.1 P2P: from Program to Process"></a>1.1.1 P2P: from Program to Process</h3><p>  hello.c首先经过gcc的预处理，进行头文件的展开、注释删除和宏定义等一系列操作，获得hello.i；然后对hello.i进行编译，将C语言代码翻译成汇编程序hello.s；再通过gcc将其汇编成为可重定位目标文件hello.o；最后使用动态链接器将hello.o与所需的库文件进行链接，生成可执行目标程序hello。在bash中执行该文件，bash会fork出一个子进程，为其分配相应的内存资源，然后调用execve执行hello，hello作为一个进程开始运行。</p>
<h3 id="1-1-2-020-from-Zero-0-to-Zero-0"><a href="#1-1-2-020-from-Zero-0-to-Zero-0" class="headerlink" title="1.1.2 020: from Zero-0 to Zero-0"></a>1.1.2 020: from Zero-0 to Zero-0</h3><p>在bash中执行hello时，bash会fork出一个子进程，然后为其分配内存资源，然后调用execve执行hello，将hello的各段内容加载入内存。这是hello在内存中从无到有的过程。在hello的执行过程中，需要对计算机中的各种数据进行操作。这些数据常常要经过多级存储（磁盘、主存、Cache等）而被hello所使用，并在过程中使用页表、TLB等辅助存储，实现访存的加速。而I/O管理与信号处理等相互结合，完成hello中printf内容从键盘、内存、显卡，再到屏幕的工作。当进程执行结束后，操作系统对hello进程进行回收，释放进程所占内存空间，实现020。</p>
<h2 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h2><h3 id="1-2-1-硬件环境"><a href="#1-2-1-硬件环境" class="headerlink" title="1.2.1 硬件环境"></a>1.2.1 硬件环境</h3><p>Intel Core i7-9750h；16G RAM；1TB Disk；</p>
<h3 id="1-2-2-软件环境"><a href="#1-2-2-软件环境" class="headerlink" title="1.2.2 软件环境"></a>1.2.2 软件环境</h3><p>Windows10 64bit；WSL 2；Ubuntu 20.04 LTS 64bit；</p>
<h3 id="1-2-3-开发工具"><a href="#1-2-3-开发工具" class="headerlink" title="1.2.3 开发工具"></a>1.2.3 开发工具</h3><p>Visual Studio Code；vi/vim/gcc；edb-debugger</p>
<h2 id="1-3-中间结果"><a href="#1-3-中间结果" class="headerlink" title="1.3 中间结果"></a>1.3 中间结果</h2><table>
<thead>
<tr>
<th><strong>文件名</strong></th>
<th><strong>文件作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hello.c</td>
<td>hello程序C源码</td>
</tr>
<tr>
<td>hello.i</td>
<td>hello.c 经过预处理之后生成的文本文件</td>
</tr>
<tr>
<td>hello.s</td>
<td>hello.i 编译后生成的汇编格式文件</td>
</tr>
<tr>
<td>hello.o</td>
<td>hello.s 汇编后生成的可重定位目标文件</td>
</tr>
<tr>
<td>hello</td>
<td>hello.o 链接后生成的可执行目标文件</td>
</tr>
<tr>
<td>hello_before_ld.s</td>
<td>hello.o的反汇编文件</td>
</tr>
<tr>
<td>hello_after_ld.s</td>
<td>hello的反汇编文件</td>
</tr>
</tbody></table>
<h2 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h2><p>​    本章从P2P和020两个角度简要介绍了hello的生命周期，说明了本文实现hello生命周期所使用的环境与工具，介绍了各种中间结果。</p>
<h1 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h1><h2 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h2><p>预处理（或称预编译）是指在进行编译的第一遍扫描（词法扫描和语法分析）之前所作的工作。预处理指令指示在程序正式编译前就由编译器进行的操作，可放在程序中任何位置。</p>
<p>预处理是C语言的一个重要功能，它由预处理程序负责完成。当对一个源文件进行编译时，系统将自动引用预处理程序对源程序中的预处理部分作处理，处理完毕自动进入对源程序的编译。C语言提供多种预处理功能，主要处理 “#” 开始的预编译指令，如宏定义 (#define) 、文件包含 (#include) 、条件编译 (#ifdef) 等。合理使用预处理功能编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。</p>
<h2 id="2-2在Ubuntu下预处理的命令"><a href="#2-2在Ubuntu下预处理的命令" class="headerlink" title="2.2在Ubuntu下预处理的命令"></a>2.2在Ubuntu下预处理的命令</h2><p>gcc -m64 -Og -no-pie -fno-PIC -E hello.c -o hello.i</p>
<p>bash中输入命令，目录下生成 hello.i 文件。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163017684.png" alt="image-20210623163017684"></p>
<p>图2-1 bash中预处理命令</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163022054.png" alt="image-20210623163022054"></p>
<p>图2-2 预处理生成文件hello.i</p>
<h2 id="2-3-Hello的预处理结果解析"><a href="#2-3-Hello的预处理结果解析" class="headerlink" title="2.3 Hello的预处理结果解析"></a>2.3 Hello的预处理结果解析</h2><p>hello.c中只使用了 #include 方法，所以预处理所做的只是去除所有的注释，然后把所包含的头文件（以及头文件中所包含的头文件）全部展开，依次加到预处理后文件中，例如函数声明、结构体定义、宏定义等。</p>
<p>最后是hello.c中的main函数代码，并没有对该函数进行改动。</p>
<p>不包含注释，hello.c一共为22行，预处理之后变为3904行，长度大大增加。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163029745.png" alt="image-20210623163029745"></p>
<p>图2-3 hello.i中部分代码截图（1）</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163034757.png" alt="image-20210623163034757"></p>
<p>图2-4 hello.i中部分代码截图（2）</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163040746.png" alt="image-20210623163040746"></p>
<p>图2-5 最后为hello.c中的原始函数</p>
<h2 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h2><p>本章介绍了预处理的概念及其作用，并且通过命令行使用gcc对hello.c进行了预处理，生成了预处理后的文件hello.i，并对其进行了分析。</p>
<h1 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h1><h2 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h2><p>注意：这儿的编译是指从 .i 到 .s 即预处理后的文件到生成汇编语言程序</p>
<p>编译是指编译是读取预处理后的源程序，对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码的过程。</p>
<p>编译除了为下一步汇编做好准备，同时也包含了一部分优化的工作，例如删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除，等等。</p>
<h2 id="3-2-在Ubuntu下编译的命令"><a href="#3-2-在Ubuntu下编译的命令" class="headerlink" title="3.2 在Ubuntu下编译的命令"></a>3.2 在Ubuntu下编译的命令</h2><p>gcc -m64 -Og -no-pie -fno-PIC -S hello.i -o hello.s</p>
<p>bash中输入命令，目录下生成 hello.s 文件。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163053918.png" alt="image-20210623163053918"></p>
<p>图3-1 bash中编译命令</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163057492.png" alt="image-20210623163057492"></p>
<p>图3-2 编译后生成hello.s</p>
<h2 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h2><p>3.3.1 字符串</p>
<p>第一个字符串是 printf()的参数：”用法: Hello 学号 姓名 秒数！\n”<br> 在汇编文件中保存为如下格式：</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163103356.png" alt="image-20210623163103356"></p>
<p>图3-3 “用法: Hello 学号 姓名 秒数！\n”</p>
<p>其中，中文字符以\xxx的三位八进制转义方式保存，三个连续的三位八进制数表示一个UTF-8编码的中文字符，在内存中占3个字节。</p>
<p>  第二个字符串也是printf()的参数：”Hello %s %s\n”，在汇编文件中的表示方式如下：</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163109087.png" alt="image-20210623163109087"></p>
<p>图3-4 “Hello %s %s\n”</p>
<p>3.3.2 整型</p>
<p>  int i 是循环的计数器，虽然在一开始被定义，但是直到后面的循环开始时才在汇编代码中出现，存储在 %ebp 寄存器中。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163113705.png" alt="image-20210623163113705"></p>
<p>图3-5 初始化int i的汇编代码</p>
<p>  int argc 作为 main 函数的参数传入，表示 argv 中参数的个数。存储在 %edi 寄存器中。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163123211.png" alt="image-20210623163123211"></p>
<p>图3-6 argc存储在%edi中</p>
<p>exit(1), argv[1], argv[2], argv[3], argc != 4, … 中的整型是幻数(magic number)，在汇编代码中表现为立即数。</p>
<p>3.3.3 数组</p>
<p>  char *argv[] 字符串指针数组，是 main 的参数，即以空格分割的命令行参数。其中每个元素为char *，大小为8 bytes，依次存储在一块连续的内存空间中。在程序中，该数组的起始地址通过 %rsi 传入，然后被保存到 %rbx 中。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163129497.png" alt="image-20210623163129497"></p>
<p>图3-7 数组地址保存在%rbx中</p>
<p>3.3.4 赋值</p>
<p>  i = 0 在3.3.2节中，可以看到，汇编代码通过 movl 语句，将立即数 $0 赋给 %ebp，从而对i赋初值。</p>
<p>3.3.5 类型转换</p>
<p>atoi(argv[3]) 将字符串转成对应的整型变量。在汇编代码中，首先将 argv[3]的地址存储到 %rdi 中，作为调用函数的传入参数，然后调用 strtol ，该函数的作用是将字符串转换成长整型。最后将结果保存在 %rax 中然后返回。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163137056.png" alt="image-20210623163137056"></p>
<p>图3-8 调用strtol转换</p>
<p>3.3.6 算术操作</p>
<p>i++ : i自增1，在汇编代码中，使用addl进行此操作，给 %ebp 中存的值加上一个立即数 $1。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163141706.png" alt="image-20210623163141706"></p>
<p>图3-9 i++对应的汇编代码</p>
<p>3.3.7 关系操作</p>
<p>  argc != 4 ：使用cmpl，将存储在 %edi 中的 argc 与立即数 $1 相比较，设置flag bits，之后配合 jne 判断ZF是否等于0，实现条件跳转</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163147178.png" alt="image-20210623163147178"></p>
<p>图3-10 将argc与4比较</p>
<p>  i &lt; 8 ：使用cmpl，将存储在 %ebp 中的 i 与立即数 $7 相比较，设置flag bits，之后配合 jle 判断（实现条件跳转）</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163154786.png" alt="image-20210623163154786"></p>
<p>图3-11 将i与8比较</p>
<p>3.3.8 指针操作</p>
<p>  argv[1], argv[2], argv[3]：由于数组是存储在一块连续的内存空间中的，所以可以通过相对偏移来访问数组元素。例如，argv[2]在汇编中的访问操作如下：</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163159660.png" alt="image-20210623163159660"></p>
<p>图3-12 访问argv[2]</p>
<p>%rbx 是 argv 的起始地址，其中每个元素占8个字节，所以 argv[2] 相对起始地址偏移量为 2 * 8 = 16，所以使用 16(%rbx) 来访问 argv[2]。</p>
<p>3.3.9 控制转移</p>
<p>  if (argc != 4)：见3.3.7节</p>
<p>  for (i = 0; i &lt; 8; i++): 首先通过28行的语句，将 %ebp 即 i 初始化为0，然后跳转至50行，判断循环继续的条件，如果满足就跳转到36行，执行循环中的代码。每次循环结束后，在48行执行 i++,然后再次判断循环继续的条件。直到不满足条件，就不进行51行的跳转。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163214344.png" alt="image-20210623163214344"></p>
<p>图3-13 for循环过程</p>
<p>3.3.10 函数操作</p>
<p>  在64位模式下，函数参数是按照 %rdi, %rsi, %rdx, %rcx, %r8, %r9，stack… 的顺序传入被调用函数的，返回值保存在 %rax 中返回给调用者。</p>
<p>  程序开始执行后，先调用一些系统函数和库函数，进行初始化，然后会运行__libc_start_main 调用 main 函数，开始执行我们所编写的代码。main函数中还调用了其它函数：例如printf, getchar, exit, sleep, atoi等，在汇编代码中，都是通过先设置传入参数，然后 call [funcname] 的方式实现的。</p>
<p>printf：第一次 printf 将 %rdi设置为“用法: Hello 学号 姓名 秒数！\n”字符串的地址，因为只有一个字符串参数，所以被优化为 puts 。第二次 printf 设置 %rdi 为 “Hello %s %s\n” 字符串的地址，设置 %rsi为argv[1]，%rdx为argv[2]，然后call __printf_chk。</p>
<p>exit：将 %edi 设置为1，然后 call exit。</p>
<p>sleep：将 %rdi 设置为 %rax，即 atoi 的返回值，然后 call sleep。</p>
<p>getchar：先将 %rdi 设置为 stdin(%rip)，即将标准输入作为函数调用的参数，然后call getc</p>
<p>atoi：实际调用的是strtol函数，该函数声明为long int strtol(const char *nptr,char **endptr,int base)；42行表示将字符串首地址作为第一个参数传入，43行表示将立即数 $10 作为第三个参数传入，意为使用十进制的方式解析该字符串，44行表示将立即数 $0 作为第二个参数传入，是传出参数，在函数返回时指向后面未被识别的第一个字符（见图3-8）。</p>
<h2 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h2><p>本章将 hello.i 从C代码编译为基于处理器的汇编代码 hello.s ，向着运行程序的方向迈出了巨大的一步。然后我们分析了C语言的各种数据和操作在汇编代码中的表现形式，有助于我们在了解C语言的基础上，更深刻地理解汇编语言。</p>
<h1 id="第4章-汇编"><a href="#第4章-汇编" class="headerlink" title="第4章 汇编"></a>第4章 汇编</h1><h2 id="4-1-汇编的概念与作用"><a href="#4-1-汇编的概念与作用" class="headerlink" title="4.1 汇编的概念与作用"></a>4.1 汇编的概念与作用</h2><p>注意：这儿的汇编是指从 .s 到 .o 即编译后的文件到生成机器语言二进制程序的过程。</p>
<p>汇编是指把汇编语言翻译成机器语言（即二进制目标文件）的过程。汇编器能够将汇编语言翻译成二进制的机器指令，生成可重定位目标文件。</p>
<h2 id="4-2-在Ubuntu下汇编的命令"><a href="#4-2-在Ubuntu下汇编的命令" class="headerlink" title="4.2 在Ubuntu下汇编的命令"></a>4.2 在Ubuntu下汇编的命令</h2><p>gcc -m64 -Og -no-pie -fno-PIC -c hello.s -o hello.o</p>
<p>bash中输入命令，目录下生成 hello.o 文件。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163227290.png" alt="image-20210623163227290"></p>
<p>图4-1 bash中汇编命令</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163230707.png" alt="image-20210623163230707"></p>
<p>图4-2 汇编生成hello.o</p>
<h2 id="4-3-可重定位目标elf格式"><a href="#4-3-可重定位目标elf格式" class="headerlink" title="4.3 可重定位目标elf格式"></a>4.3 可重定位目标elf格式</h2><p>分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。</p>
<p>.text：已编译程序的机器码</p>
<p>.rela.text：包含.text节中的重定位位置的列表，含有该.text中所需要进行重定位操作的信息，在链接时，这些位置将会被修改。</p>
<p>.data：已初始化的全局和静态变量</p>
<p>.bss：程序中定义和引用的函数和全局变量信息</p>
<p>.rodata：只读数据，例如程序代码中的字符串</p>
<p>.comment：编译器版本等信息</p>
<p>.eh_frame：exception handling frame，gcc处理异常时生成</p>
<p>.rela.eh_frame：.eh_frame节中的重定位信息的列表</p>
<p>.symtab：存储程序中定义和引用的函数和全局变量信息</p>
<p>.strtab：.symtab和.debug中符号表以及节头部中节的名字</p>
<p>.shstrtab：段表字符串表，存储section的名字</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163241486.png" alt="image-20210623163241486"></p>
<p>图4-3 hello.o的段头部表</p>
<p>.rela.text .是存储 .text节中的重定位位置的列表，含有该.text中所需要进行重定位操作的信息，在链接时，这些位置将会被修改。其中Offset是需要重定位的信息偏移位置；Type显示重定位的类型；Symbol是被重定位时指向的符号；Append部分重定位过程中需使用它作偏移调整）</p>
<p>其中包括两次调用printf中的字符串(.rodata.str1.8, .rodata.str1.1)，还有main中调用的各种函数。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163250476.png" alt="image-20210623163250476"></p>
<p>图4-4 .rela.text重定位段</p>
<h2 id="4-4-Hello-o的结果解析"><a href="#4-4-Hello-o的结果解析" class="headerlink" title="4.4 Hello.o的结果解析"></a>4.4 Hello.o的结果解析</h2><p>说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。</p>
<p>总体上，反汇编的结果与hello.s十分类似，但是在以下几点上有明显的不同：</p>
<p>1． 分支转移<br> hello.s中使用.LC0, .LC3等段名称标记跳转位置，而这些段在目标文件中并不是实际存在的，所以反汇编中不使用段名称，而是使用相对main函数的偏移量指示跳转目标。</p>
<p>2． 函数调用</p>
<p>hello.s中使用 call [funcname] 的方式调用函数，而在可重定位目标文件中，无法使用函数名来调用函数，因此该位置留空，在链接时根据重定位表中的重定位信息来链接函数或者在运行时链接共享库。</p>
<h2 id="4-5-本章小结"><a href="#4-5-本章小结" class="headerlink" title="4.5 本章小结"></a>4.5 本章小结</h2><p>本章主要介绍了汇编的概念及其作用，并通过gcc对hello.s程序进行汇编操作生成hello.o文件，对其elf格式进行了查看和内容解析。然后使用objdump反汇编hello.o，对比发现了hello.s与hello.o反汇编后的差异，主要在分支转移和函数调用这两方面。从而对汇编阶段有了更深的了解。</p>
<h1 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h1><h2 id="5-1-链接的概念与作用"><a href="#5-1-链接的概念与作用" class="headerlink" title="5.1 链接的概念与作用"></a>5.1 链接的概念与作用</h2><p>注意：这儿的链接是指从 hello.o 到hello生成过程。</p>
<p>链接 (linking) 指将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。链接可以在编译时执行，即源代码被翻译成机器代码时；可以在加载时执行，即程序被加载器加载到内存并执行时；可以在运行时执行，即由应用程序来执行。</p>
<p>链接的作用是将一个目标文件(hello.o)或多个目标文件外加库链接合并为一个可执行目标文件(hello)，可执行目标文件可以被加载到内存中，由系统执行。</p>
<h2 id="5-2-在Ubuntu下链接的命令"><a href="#5-2-在Ubuntu下链接的命令" class="headerlink" title="5.2 在Ubuntu下链接的命令"></a>5.2 在Ubuntu下链接的命令</h2><p>ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o</p>
<p>bash中输入命令，目录下生成 hello文件。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163302227.png" alt="image-20210623163302227"></p>
<p>图5-1 bash中输入链接命令</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163305524.png" alt="image-20210623163305524"></p>
<p>图5-2 链接后生成hello</p>
<h2 id="5-3-可执行目标文件hello的格式"><a href="#5-3-可执行目标文件hello的格式" class="headerlink" title="5.3 可执行目标文件hello的格式"></a>5.3 可执行目标文件hello的格式</h2><p>分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。</p>
<p>.plt：procedure linkage table，用于定位过程的数据信息，保存了某些符号在重定位表中的偏移量和对应的.got.plt的对应的地址。</p>
<p>.got：global offset table，保存全局变量引用的地址</p>
<p>.text：已编译程序的机器码</p>
<p>.data：已初始化的全局和静态变量</p>
<p>.bss：程序中定义和引用的函数和全局变量信息</p>
<p>.rodata：只读数据，例如程序代码中的字符串</p>
<p>.comment：编译器版本等信息</p>
<p>.eh_frame：exception handling frame，gcc处理异常时生成</p>
<p>.symtab：存储程序中定义和引用的函数和全局变量信息</p>
<p>.strtab：.symtab和.debug中符号表以及节头部中节的名字</p>
<p>.shstrtab：段表字符串表，存储section的名字</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163312109.png" alt="image-20210623163312109"></p>
<p>图5-3 hello的段头部表（1）</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163317744.png" alt="image-20210623163317744"></p>
<p>图5-4 hello的段头部表（2）</p>
<h2 id="5-4-hello的虚拟地址空间"><a href="#5-4-hello的虚拟地址空间" class="headerlink" title="5.4 hello的虚拟地址空间"></a>5.4 hello的虚拟地址空间</h2><p>使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。  </p>
<p>hello进程的在虚拟地址空间中，起始地址为0x400000，与5.3中通过readelf所获取的各段起始地址直接对应，section header中address项所对应的值即为各个段的在虚拟地址空间中的起始地址。</p>
<p>例如：从section header表中可以看出 .text 段的起始地址为0x4010f0，则在edb 的 Data Dump 中找到4010f0，即为 .text 段。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163323544.png" alt="image-20210623163323544"></p>
<p>图5-5 hello虚拟地址空间各段</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163326988.png" alt="image-20210623163326988"></p>
<p>图5-6 hello虚拟地址空间.text段</p>
<h2 id="5-5-链接的重定位过程分析"><a href="#5-5-链接的重定位过程分析" class="headerlink" title="5.5 链接的重定位过程分析"></a>5.5 链接的重定位过程分析</h2><p>5.5.1 函数解析</p>
<p>在使用ld命令链接的时候，使用的动态链接器为 /lib64/ld-linux-x86-64.so.2, 除hello.o外，其余参加链接过程的目标文件有crt1.o, crti.o，crtn.o, libc.so，这些文件包含了程序入口_start、初始化函数_init、_start中调用的__libc_csu_init，__libc_csu_fini等。在链接过程中，链接器将这些函数直接加入到生成的目标文件中。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163331914.png" alt="image-20210623163331914"></p>
<p>图5-7 hello反汇编中_start函数</p>
<p>hello.o中对外部函数调用（puts, __printf_chk, sleep, getc, exit, strtol等函数）的类型为R_X86_64_PLT32的重定位，此时动态链接库中的函数已经加入到了PLT中，由于.text与.plt节相对距离已经确定，链接器计算相对距离，将对动态链接库中函数的调用值改为 .plt 中相应函数与下条指令的相对地址，指向对应函数。同时，链接器为其构造.plt与.plt.sec。</p>
<p>5.5.2 .rodata引用</p>
<p>hello.o中存在两个类型为R_X86_64_32的对.rodata的重定位（printf中的两个字符串）。由于.rodata与.text节之间的相对距离确定，因此链接器直接修改call之后的值为目标地址与下一条指令的地址之差，指向相应的字符串。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163338302.png" alt="image-20210623163338302"></p>
<p>图5-8 hello.o中引用.rodata.str1.8</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163341567.png" alt="image-20210623163341567"></p>
<p>图5-9 hello中引用.rodata.str1.8</p>
<h2 id="5-6-hello的执行流程"><a href="#5-6-hello的执行流程" class="headerlink" title="5.6 hello的执行流程"></a>5.6 hello的执行流程</h2><p>使用edb执行hello，分析从加载hello到_start，到call main,以及程序终止的所有过程，得出如下结论：</p>
<p>在main函数之前执行的程序有：_start, _init, __libc_csu_init , __libc_start_main_init、frame_dummy、register_tm_clones。然后执行main函数，其中依次调用了puts, __printf_chk, strtol, sleep, getc, (exit, )。在main函数之后执行的函数有：_fini, __run_exit_handlers, __lll_cas_lock。</p>
<h2 id="5-7-Hello的动态链接分析"><a href="#5-7-Hello的动态链接分析" class="headerlink" title="5.7 Hello的动态链接分析"></a>5.7 Hello的动态链接分析</h2><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时还是需要用到动态链接库。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163348480.png" alt="image-20210623163348480"></p>
<p>图5-10 dl_init之后</p>
<h2 id="5-8-本章小结"><a href="#5-8-本章小结" class="headerlink" title="5.8 本章小结"></a>5.8 本章小结</h2><p>本章介绍了程序的链接过程，通过elf文件结构和反汇编代码，静态对比了程序链接前后的变化；同时又通过edb调试运行，分析了程序运行的流程。对于链接的流程与作用有了更深的了解。</p>
<h1 id="第6章-hello进程管理"><a href="#第6章-hello进程管理" class="headerlink" title="第6章 hello进程管理"></a>第6章 hello进程管理</h1><h2 id="6-1-进程的概念与作用"><a href="#6-1-进程的概念与作用" class="headerlink" title="6.1 进程的概念与作用"></a>6.1 进程的概念与作用</h2><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</p>
<h2 id="6-2-简述壳Shell-bash的作用与处理流程"><a href="#6-2-简述壳Shell-bash的作用与处理流程" class="headerlink" title="6.2 简述壳Shell-bash的作用与处理流程"></a>6.2 简述壳Shell-bash的作用与处理流程</h2><p>Linux实质上是一个操作系统内核，一般用户不能直接使用内核，而是通过外壳程序，也就是所谓的shell来与内核进行沟通。外壳程序可以保证操作系统的安全性，抵御用户的一些不正确操作。Linux的外壳程序称作shell（命令行解释器），它能够将命令翻译给内核、将内核处理结果翻译给用户。一般我们使用的shell为bash。在解释命令的时候，bash不会直接参与解释，而是创建新进程进行命令的解释，bash只用等待结果即可，这样能保证bash进程的安全。</p>
<p>首先 shell检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux 本身的实用程序，如ls 和rm；也可以是购买的商业程序，如xv；或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果输入的命令不是一个内部命令且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能找到命令，该内部命令或应用程序分解后将被系统调用并传给Linux 内核。</p>
<h2 id="6-3-Hello的fork进程创建过程"><a href="#6-3-Hello的fork进程创建过程" class="headerlink" title="6.3 Hello的fork进程创建过程"></a>6.3 Hello的fork进程创建过程</h2><p>一个进程，包括代码、数据和分配给进程的资源。fork函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。一个进程调用fork函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p>
<h2 id="6-4-Hello的execve过程"><a href="#6-4-Hello的execve过程" class="headerlink" title="6.4 Hello的execve过程"></a>6.4 Hello的execve过程</h2><p>execve函数在当前进程(bash)的上下文中加载并运行可执行目标文件hello，并且带参数列表argv和环境变量envp。如果出现错误，例如找不到filename（hello），execve才会返回到调用程序。与fork一次调用返回两次不同，execve调用一次并从不返回。</p>
<p>在execve加载了hello之后，它会调用启动代码（_start, __libc_start_main）。启动代码设置栈，并将控制传递给hello的main函数。</p>
<p><img src="/2021/06/23/HelloLife/image-20210623163402283.png" alt="image-20210623163402283"></p>
<p>图6-1 hello进程的argv和envp</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163405908.png" alt="image-20210623163405908"></p>
<p>图6-2 hello进程的栈空间示意图</p>
<h2 id="6-5-Hello的进程执行"><a href="#6-5-Hello的进程执行" class="headerlink" title="6.5 Hello的进程执行"></a>6.5 Hello的进程执行</h2><p>结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。</p>
<p>运行hello的同时，系统中有其他程序在运行，但是进程可以让hello程序认为它在独占地使用处理器。在有多个进程并行的时候，hello执行它的流的一部分，然后被抢占，轮到其他进程。</p>
<p>进程会为hello提供私有地址空间，一般而言，和这个空间中某个地址相关联的内存字节是不能被其它进程读或者写的。地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址0x400000开始。地址空间顶部保留给内核(操作系统常驻内存的部分)。地址空间的这个部分包含内核在代表进程执行指令时(比如当应用程序执行系统调用时)使用的代码、数据和栈。</p>
<p>内核为hello进程维持一个上下文，即就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。在hello进程执行的某些时刻，内核可以决定抢占hello进程，并重新开始一个先前被抢占了的进程。在内核调度了一个新的进程运行后，它就抢占当前进程，保存当前进程的上下文，恢复某个先前被抢占的进程被保存的上下文，将控制传递给这个新恢复的进程。</p>
<p>程序在涉及到一些操作时，例如调用一些系统函数，内核需要将当前状态从用户态切换到核心态，执行结束后再及时改用户态，从而保证系统的安全与稳定。</p>
<h2 id="6-6-hello的异常与信号处理"><a href="#6-6-hello的异常与信号处理" class="headerlink" title="6.6 hello的异常与信号处理"></a>6.6 hello的异常与信号处理</h2><p>hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。</p>
<p>程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill 等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。</p>
<p>不停乱按，回车：会在屏幕上显示出对应的输入，但一般不会干扰程序的正常运行。</p>
<p>Ctrl-C：终止hello进程。同时父进程（此处为bash）会回收子进程</p>
<p>Ctrl-Z：挂起hello进程，可以运行ps jobs pstree fg kill 等命令</p>
<p><img src="/2021/06/23/HelloLife/image-20210623163419191.png" alt="image-20210623163419191"></p>
<p>图6-3 程序挂起时调用内置命令</p>
<h2 id="6-7本章小结"><a href="#6-7本章小结" class="headerlink" title="6.7本章小结"></a>6.7本章小结</h2><p>本章介绍了进程的概念和作用，并且结合hello进程的运行，分析了bash的处理流程，hello的fork，execve的执行过程，最后通过将hello进程挂起和终止，分析了hello的异常与信号处理。</p>
<h1 id="第7章-hello的存储管理"><a href="#第7章-hello的存储管理" class="headerlink" title="第7章 hello的存储管理"></a>第7章 hello的存储管理</h1><h2 id="7-1-hello的存储器地址空间"><a href="#7-1-hello的存储器地址空间" class="headerlink" title="7.1 hello的存储器地址空间"></a>7.1 hello的存储器地址空间</h2><p>逻辑地址：由程序产生的与段有关的偏移地址。分为两个部分，一个部分为段基址，另一个部分为段偏移量。在hello.o中即为相对偏移地址。</p>
<p>线性地址：地址空间是一个非负整数地址的有序集合，如果此时地址空间中的整数是连续的，则我们称这个地址空间为线性地址空间。hello.o中的偏移地址与基地址相加后即为线性地址。</p>
<p>虚拟地址：CPU启动保护模式后，程序访问存储器所使用的逻辑地址称为虚拟地址，与实地址模式下的分段地址类似，虚拟内存被组织为一个存放在磁盘上的 N 个连续的字节大小的单元组成的数组，其每一个字节都被给予一个唯一的地址，即虚拟地址。</p>
<p>物理地址：计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组，其每一个字节都被给予一个唯一的地址，即物理地址。hello内的虚拟地址经过地址翻译后得到的即为物理地址。</p>
<h2 id="7-2-Intel逻辑地址到线性地址的变换-段式管理"><a href="#7-2-Intel逻辑地址到线性地址的变换-段式管理" class="headerlink" title="7.2 Intel逻辑地址到线性地址的变换-段式管理"></a>7.2 Intel逻辑地址到线性地址的变换-段式管理</h2><p>逻辑地址一共有48位，前16位是段选择符。段选择符中，前13位是描述符表的索引；之后1位是TI，区分描述符表是全局描述符表还是局部描述符表。最后2位是RPL（段的级别）。</p>
<p>首先将偏移地址与基地址相加，得到有效地址。然后通过段选择符中的索引在描述符表中找到段基址，加上有效地址就得到了线性地址。</p>
<h2 id="7-3-Hello的线性地址到物理地址的变换-页式管理"><a href="#7-3-Hello的线性地址到物理地址的变换-页式管理" class="headerlink" title="7.3 Hello的线性地址到物理地址的变换-页式管理"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h2><p>线性地址被划分成一定长度为单位的组——页。所有页构成一个页表，其中每项为页的有效位和地址。CPU中的页表基址寄存器指向当前页表。线性地址分为两个部分：虚拟页面偏移(VPO)和虚拟页号(VPN)。MMU利用VPN来选择适当的PTE，将页表条目中物理页号(PPN)和虚拟地址中的VPO串联起来，就得到相应的物理地址。而对于虚拟地址和物理地址，因为大小相同，所以VPO和PPO是相同的。</p>
<h2 id="7-4-TLB与四级页表支持下的VA到PA的变换"><a href="#7-4-TLB与四级页表支持下的VA到PA的变换" class="headerlink" title="7.4 TLB与四级页表支持下的VA到PA的变换"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h2><p>Linux采用4级页表的方案，这四级列表分别为PGD（Page Global directory页全局目录），PUD（Page Upper Directory页上级目录），PMD（Page middle directory页中间目录），PTE（Page table entry页表项）。</p>
<p>多级页表节省空间的同时，也带来了一定的问题，例如一次VA到PA的转换需要进行在四级的页表中进行多次查找，开销增加，因此使用TLB（Translation Lookaside Buffer）将页表内容缓存起来。TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有  个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的。</p>
<p>对于一个给定的虚拟地址VA，MMU先在TLB中进行查询，如果有就直接返回对应的PA，如果不命中，那么再去四级页表中查找。先首先根据地址中第一部分的VPN找到PGD中的条目，指向某个特定的PUD；然后根据地址中第二部分的VPN在该PUD中找到对应的条目，指向某个特定的PMD；再根据地址中第三部分的VPN在该PMD中找到对应的条目，指向某个特定的PT；最后根据地址中第四部分的VPN在该PT中找到对应的PTE，再加上VPO（PPO）得到目标物理地址。</p>
<p> <img src="/2021/06/23/HelloLife/image-20210623163436733.png" alt="image-20210623163436733"></p>
<p>图7-1 Linux下四级页表寻址示意图</p>
<h2 id="7-5-三级Cache支持下的物理内存访问"><a href="#7-5-三级Cache支持下的物理内存访问" class="headerlink" title="7.5 三级Cache支持下的物理内存访问"></a>7.5 三级Cache支持下的物理内存访问</h2><p>在得到物理地址之后，先根据CI组索引，在L1 cache 找到对应的组，对组中各个路的块分别检查CT，如果在此过程中匹配成功，并且块的有效位为1。则缓存命中，根据CO取出数据后返回；</p>
<p>如果匹配不成功但有效位为1，则判断不命中，继续向下一级缓存中查询数据（L1 → L2 → L3 → 主存 → … ）。查到数据后，如果映射到的组内存在空闲块，则直接将其放置进去，否则产生冲突，通过使用LRU进行替换。</p>
<h2 id="7-6-hello进程fork时的内存映射"><a href="#7-6-hello进程fork时的内存映射" class="headerlink" title="7.6 hello进程fork时的内存映射"></a>7.6 hello进程fork时的内存映射</h2><p>当前进程（bash）调用fork()时，内核为hello进程创建各种数据结构，并分配给他一个唯一的PID。为了给hello进程创建虚拟内存，fork创建了当前进程的mm_struct、区域结构和页表的原样副本。并将两个进程的每个页面都标记为只读，并将两个进程中的区域结构都标记为私有的写时复制。当fork()在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此也就为每个进程保持了私有地址空间的抽象概念。</p>
<h2 id="7-7-hello进程execve时的内存映射"><a href="#7-7-hello进程execve时的内存映射" class="headerlink" title="7.7 hello进程execve时的内存映射"></a>7.7 hello进程execve时的内存映射</h2><p>execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤：</p>
<p>删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。</p>
<p>映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。</p>
<p>映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。</p>
<p>设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。</p>
<h2 id="7-8-缺页故障与缺页中断处理"><a href="#7-8-缺页故障与缺页中断处理" class="headerlink" title="7.8 缺页故障与缺页中断处理"></a>7.8 缺页故障与缺页中断处理</h2><p>  缺页故障发生在MMU将VA转换成PA时，如果该物理地址不在内存中，就会引发缺页故障。调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，将其内容复制回磁盘，然后修改该页的页表条目，表示为不在主存中。然后将目标页从磁盘复制到内存中牺牲页的位置，更新PTE，随后返回。之后重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送到地址翻译硬件，由于目标页已经缓存，所以不再会导致缺页异常。</p>
<h2 id="7-9动态存储分配管理"><a href="#7-9动态存储分配管理" class="headerlink" title="7.9动态存储分配管理"></a>7.9动态存储分配管理</h2><p>printf会调用malloc，简述动态内存管理的基本方法与策略。</p>
<p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆(heap)。堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向更高的地址生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。</p>
<p>分配器将堆视为一组不同大小的块(block)的集合来维护。每个块就是一个连续的虚拟内存片(chunk),要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。分配器有两种风格：显示分配器要求应用显式地释放任何已分配的块；隐式分配器要求分配器检测一个已分配块合适不再被程序所使用，那么就释放这个块，隐式分配器也叫做垃圾收集器。</p>
<h2 id="7-10本章小结"><a href="#7-10本章小结" class="headerlink" title="7.10本章小结"></a>7.10本章小结</h2><p>本章探讨了hello进程与内存的交互，包括各类地址的含义、地址之间的翻译转换过程，物理内存访问、缺页异常的产生及其处理方式、fork和execve的内存映射、以及动态内存分配的基本原理。对进程在内存中的映射和交互有了更深的理解。</p>
<h1 id="第8章-hello的IO管理"><a href="#第8章-hello的IO管理" class="headerlink" title="第8章 hello的IO管理"></a>第8章 hello的IO管理</h1><h2 id="8-1-Linux的IO设备管理方法"><a href="#8-1-Linux的IO设备管理方法" class="headerlink" title="8.1 Linux的IO设备管理方法"></a>8.1 Linux的IO设备管理方法</h2><p>设备的模型化：文件</p>
<p>所有的I/O设备都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这样的方式允许Linux内核引出一个简单低级的应用接口：Unix I/O，使得所有输入输出都能以一种统一且一致的方式来执行。 </p>
<h2 id="8-2-简述Unix-IO接口及其函数"><a href="#8-2-简述Unix-IO接口及其函数" class="headerlink" title="8.2 简述Unix IO接口及其函数"></a>8.2 简述Unix IO接口及其函数</h2><p>8.2.1 接口</p>
<p>打开文件：一个应用程序通过要求内核打开相应的文件，表明它想要访问一个I/O设备，内核记录有关这个文件的所有信息，而返回给应用程序一个描述符，标识这个文件。</p>
<p>改变当前文件的位置：对于每一个打开的文件，内核保存着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，设置文件的当前位置。</p>
<p>读写文件：读操作是从文件复制多个字节到内存。从当前文件位置k开始，然后将k增加到k+n。当k大于等于文件大小时，执行读操作会触发EOF的条件，应用程序能够检测到这个条件。</p>
<p>关闭文件：当应用程序完成了对文件的访问后，它就通知内核关闭这个文件，作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。</p>
<p>8.2.2 函数</p>
<p>  \1. 打开文件：int open(char *filename, int flags, mode _t mode)</p>
<p>open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件：例如：O_RDONLY：只读，O_WRONLY：只写，O_RDWR：可读可写。</p>
<p>\2. 关闭文件：int close(int fd);</p>
<p>  fd为文件描述符</p>
<p>\3. 读写文件：</p>
<p>ssize_t read(int fd, void *buf, size_t n);</p>
<p>  ssize_t write(int fd, const void *buf, size_t n);</p>
<p>  read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。write函数从内存位置buf复制至多n个字节到描述符fd 的当前文件位置。</p>
<h2 id="8-3-printf的实现分析"><a href="#8-3-printf的实现分析" class="headerlink" title="8.3 printf的实现分析"></a>8.3 printf的实现分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">   va_list arg = (va_list)((<span class="keyword">char</span>*)(&amp;fmt) + <span class="number">4</span>);</span><br><span class="line">   i = <span class="built_in">vsprintf</span>(buf, fmt, arg);</span><br><span class="line">   write(buf, i);</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arg通过保存第一个参数地址，保存了参数列表；然后调用vsprintf，它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出，并返回生成的输出字符串的长度。然后调用write函数，向标准输出输出buf字符数组的内容（即通过vsprintf生成的字符串）。在write中，先向寄存器中传递几个参数，然后int 21h语句引发中断，调起INT_VECTOR_SYS_CALL，即通过系统调用sys_call，切换到内核态，由系统控制字符串的输出。</p>
<p>VRAM中存放的是子符的ASCII码，不是点阵信息。若要显示出字符的形状，还需要有字符发生器(字符库)的支持。ASCII和汉字库点阵是现成的，根据ASCII码或GBK码在点阵数组或汉字库中直接获取字体的点阵。字符发生器的高位地址来自VRAM的ASCII码，低位地址来自行计数器的输出(行扫描线序号)，它具体指向这个字形点阵中的某个字节为了不断提供刷新画面的信号。无论采用字符还是图形显示模式，都必须把字符或图形信息存储在一个显示缓冲区(VRAM)。显示芯片按照刷新频率逐行读取VRAM，并通过信号线向液晶显示器传输每一个点（RGB分量）</p>
<h2 id="8-4-getchar的实现分析"><a href="#8-4-getchar的实现分析" class="headerlink" title="8.4 getchar的实现分析"></a>8.4 getchar的实现分析</h2><p>异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。</p>
<p>getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。</p>
<p>getchar代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> c;</span><br><span class="line">   <span class="keyword">return</span> (read(<span class="number">0</span>,&amp;c,<span class="number">1</span>)==<span class="number">1</span>)?(<span class="keyword">unsigned</span> <span class="keyword">char</span>)c:EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getchar通过调用read函数返回字符。其中read函数的第一个参数是描述符fd，0代表标准输入。第二个参数输入内容的指针，这里也就是字符c的地址，第三个参数是1，表示读入1个字符。read函数的返回值是读入的字符数，如果为1说明读入成功，那么直接返回字符，否则说明读到了buf的最后。</p>
<p>read函数同样通过sys_call中断来调用内核中的系统函数。键盘中断处理子程序会接受按键扫描码并将其转换为ASCII码后保存在缓冲区。然后read函数调用的系统函数可以对缓冲区ASCII码进行读取，直到接受回车键返回。</p>
<h2 id="8-5本章小结"><a href="#8-5本章小结" class="headerlink" title="8.5本章小结"></a>8.5本章小结</h2><p>本章主要介绍了Linux的I/O设备管理、接口和函数，并结合代码阐述了了printf和getchar的具体实现，分析了其处理流程。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>hello.c首先经过gcc的预处理，进行头文件的展开、注释删除和宏定义等一系列操作，获得hello.i；然后对hello.i进行编译，将C语言代码翻译成汇编程序hello.s；再通过gcc将其汇编成为可重定位目标文件hello.o；最后使用动态链接器将hello.o与所需的库文件进行链接，生成可执行目标程序hello。在bash中执行该文件，bash会fork出一个子进程，为其分配相应的内存资源，然后调用execve执行hello，hello作为一个进程开始运行。在hello的执行过程中，需要对计算机中的各种数据进行操作。这些数据常常要经过多级存储（磁盘、主存、Cache等）而被hello所使用，并在过程中使用页表、TLB等辅助存储，实现访存的加速。而I/O管理与信号处理等相互结合，完成hello中printf内容从键盘、内存、显卡，再到屏幕的工作。当进程执行结束后，操作系统对hello进程进行回收，释放进程所占内存空间，hello结束其生命周期。</p>
<p>计算机系统的设计是严密而精巧、环环相扣的。通过追踪hello的一生，我对计算机系统有了更深的了解。</p>
<h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><table>
<thead>
<tr>
<th><strong>文件名</strong></th>
<th><strong>文件作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hello.c</td>
<td>hello程序C源码</td>
</tr>
<tr>
<td>hello.i</td>
<td>hello.c  经过预处理之后生成的文本文件</td>
</tr>
<tr>
<td>hello.s</td>
<td>hello.i  编译后生成的汇编格式文件</td>
</tr>
<tr>
<td>hello.o</td>
<td>hello.s  汇编后生成的可重定位目标文件</td>
</tr>
<tr>
<td>hello</td>
<td>hello.o  链接后生成的可执行目标文件</td>
</tr>
<tr>
<td>hello_before_ld.s</td>
<td>hello.o的反汇编文件</td>
</tr>
<tr>
<td>hello_after_ld.s</td>
<td>hello的反汇编文件</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Randal E. Bryant, David R. O’Hallaron..深入理解计算机系统[M].机械工业出版社:北京,2016:1-732.</p>
<p>[2] 段页式访存——逻辑地址到线性地址的转换[EB/OL]. <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fd2611cc808e">https://www.jianshu.com/p/fd2611cc808e</a>, 2019-05-19.</p>
<p>[3] Linux四级页表及其原理[EB/OL]. <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/242ba363e4ed">https://www.jianshu.com/p/242ba363e4ed</a>, 2019-11-26.</p>
<p>[4] printf 函数实现的深入剖析[EB/OL]. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/pianist/p/3315801.html">https://www.cnblogs.com/pianist/p/3315801.html</a>, 2013-09-11.</p>
<p>[5] ASCII字符点阵和汉字库点阵显示[EB/OL]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22863733/article/details/79723823">https://blog.csdn.net/qq_22863733/article/details/79723823</a>, 2018-03-28.</p>

    </div>

    <div class="about">
        <h1>About this Post</h1>
        <p>This post is written by Marcus Lee, licensed under <a
                target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
    </div>

    
        
    
</article>
        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h4 class="title">Blog</h4>
                
                <a href="/" class="item" target="_blank">Blog</a>
                
                <a href="/archives" class="item" target="_blank">Archives</a>
                
                <a href="/friends" class="item" target="_blank">Friends</a>
                
                <a href="/projects" class="item" target="_blank">Projects</a>
                
                <a href="/resume" class="item" target="_blank">Resume</a>
                
                <a href="/about" class="item" target="_blank">About</a>
                
                <a href="/atom.xml" class="item" target="_blank">RSS</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Projects</h4>
                
                <a href="https://github.com/transmister" class="item" target="_blank">Transmister</a>
                
                <a href="https://github.com/MrWillCom/css-and-js-windows-uwp-xaml-controls" class="item" target="_blank">CSS&amp;JS Windows UWP XAML Controls</a>
                
                <a href="https://github.com/MrWillCom/hexo-theme-cupertino" class="item" target="_blank">Theme Cupertino</a>
                
                <a href="https://github.com/MrWillCom/github-dark-mode" class="item" target="_blank">GitHub Dark Mode</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Me</h4>
                
                <a href="https://github.com/MarkusLee" class="item" target="_blank">GitHub</a>
                
                <a href="mailto:lxmarcus@foxmail.com" class="item" target="_blank">Email</a>
                
            </div>
            
        </div>
        &copy; 2021 Marcus Lee<br />
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
</footer>

        
<script src="/js/main.js"></script>

        
    </body>
</html>